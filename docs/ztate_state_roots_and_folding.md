# Ztate-State, RPP/Pruning-Commitments und Folding-Eingänge

Das Sequenzdiagramm unter [`docs/architecture/ztate_state_folding_interaction.md`](architecture/ztate_state_folding_interaction.md) visualisiert die Schnittstellen zwischen Prover, `ztate/state`, Consensus und Storage, markiert die bestehenden Aggregationsstufen und zeigt, wo der neue Folding-Schritt (`GlobalProof`) eingehängt wird.

## 1. Aktuelle Commitments und State-Roots
- **Globale Ztate-State-Commitments:** Das Ledger emittiert einen Satz aus sechs Commitment-Wurzeln (Global-Accounts, UTXO, Reputation, Timetoke, ZSI-Registry, Proof-Registry). Sie werden im Block-Header gespiegelt und bilden den Stand der "ztate"-Substates ab (`global_state_root`, `utxo_root`, `reputation_root`, `timetoke_root`, `zsi_root`, `proof_root`).【F:rpp/proofs/rpp.rs†L377-L406】【F:rpp/runtime/node.rs†L9488-L9510】【F:rpp/storage/ledger.rs†L1180-L1190】
- **Pruning/Recovery-Roots (RPP):** Jede Pruning-Checkpoint-Datei speichert den gerade committed State-Root und bricht die Rotation ab, falls die manifestierte Wurzel nicht zum Commit passt. Recovery- und Cross-Backend-Drills prüfen zudem, dass der Pruning-Proof für den finalisierten Head gegen den erwarteten State-Root validiert werden kann.【F:docs/storage/pruning.md†L15-L36】【F:docs/storage/pruning.md†L71-L95】
- **State-Sync/Light-Client-Roots:** Snapshot-Manifeste und Light-Client-Updates tragen den Firewood-State-Root und eine zusammengeführte Root-Commitment-Kette. Die Verifikation stoppt, wenn Wurzeln in Plan, Pruning-Receipts oder Chunk-Proofs voneinander abweichen.【F:docs/state_sync.md†L10-L38】【F:docs/state_sync.md†L30-L37】

## 2. Vorläufiges Schema für `GlobalInstance I_i`
Ein Instanzobjekt aggregiert die öffentlichen Inputs eines Folding-Schritts für Block *i*:

| Feld | Beschreibung |
| ---- | ------------ |
| `height_i` | Blockhöhe des Instanzschritts (offen verfügbar über Light-Client-Update). |
| `C_state_i` | Bündel aller sechs Substate-Commitments aus dem Header (`global_state_root`, `utxo_root`, `reputation_root`, `timetoke_root`, `zsi_root`, `proof_root`).【F:rpp/runtime/node.rs†L9488-L9510】 |
| `C_rpp_i` | Commitment der Pruning-Witness (z. B. letzter `snapshot-<height>.json`) inkl. Referenz auf den verifizierten State-Root; dient als Boundary-Bedingung für den Folding-Übergang.【F:docs/storage/pruning.md†L15-L36】 |
| `C_rpp_history_i` | Sequenz/Historie der zuletzt bestätigten Pruning-Proofs und zugehörigen State-Roots, damit der Faltungsschritt nur monotone/append-only Updates akzeptiert.【F:docs/storage/pruning.md†L71-L95】 |
| `C_checkpoint_i` | Pruning-spezifische Cut-/Checkpoint-Metadaten: `cut_height`/`cut_epoch` (Höhe des jüngsten Snapshot-Cuts), `snapshot_root` (Root der Snapshot-Manifestkette) sowie optional der letzte `snapshot_leaf` (Chunk-Root). Diese Werte werden aus den Pruning-Receipts übernommen und dienen als Fortschrittsmarker, damit alte oder widersprüchliche Pruning-States nicht erneut gefaltet werden. |
| `C_checkpoint_history_i` | Zusammengefasster Commitment-Verlauf über Checkpoint- und Snapshot-Metadaten (z. B. Hash-Chain über `cut_height`/`snapshot_root`), damit Validatoren erkennen können, ob ein Pruning-Update die erwartete Monotonie verletzt oder alte Snapshots entfernt. |
| `C_rec_i` | Commitment der rekursiven Aggregation des vorherigen Blocks (`recursive_commitment`), falls vorhanden; leer bei Genesis.【F:docs/state_sync.md†L30-L37】 |
| `pp_public` | Öffentliche Parameter des verwendeten Proof-Systems (z. B. RPP-STARK/Plonky3), versioniert über Parameter-Hashes im Snapshot-Metadatenpfad.【F:docs/state_sync.md†L10-L24】 |

## 3. Nutzung bestehender Block-Proofs im Folding-Schritt
- **Prover-Inputs bündeln:** Der Prover konstruiert für Block *i* die Modul-Witnesses (`build_state_witness`, `build_pruning_witness`) und reicht sie zusammen mit den Header-Commitments an `build_recursive_witness` weiter. Dadurch fließen State- und Pruning-Commitments als öffentliche Inputs in die rekursive Aggregation ein.【F:rpp/proofs/proof_system/mod.rs†L262-L310】
- **Header-Commitments dekodieren:** Der Runtime-Knoten liest die Commitments aus dem finalisierten Header (`commitments_from_header`) und übergibt sie an den Prover. Diese Werte entsprechen exakt den öffentlichen Wurzeln, die im Folding-Schritt erneut verknüpft werden.【F:rpp/runtime/node.rs†L9488-L9510】
- **Vorherige Aggregation referenzieren:** `build_recursive_witness` akzeptiert den vorherigen rekursiven Proof (`previous_recursive`) und die aktuellen Block-Proofs. Damit entsteht eine Kette aus Block-Beweisen, deren Commitment (`recursive_commitment`) als öffentlicher Input der nächsten Instanz `I_{i+1}` dient.【F:rpp/proofs/proof_system/mod.rs†L293-L310】
- **Pruning- und State-Proofs koppeln:** Der rekursive Witness beinhaltet sowohl den Pruning-Beweis (`pruning_envelope`, `pruning_proof`) als auch die globalen State-Commitments, wodurch der Folding-Schritt garantiert, dass die neue Root (`C_state_i`) nur akzeptiert wird, wenn der zugehörige Pruning-Proof verifiziert wurde.【F:rpp/proofs/proof_system/mod.rs†L293-L310】【F:docs/storage/pruning.md†L71-L95】

## 4. Validierungen für Pruning- und Checkpoint-Updates im Folding-Schritt
- **Monotonie der Checkpoints:** `fold` lehnt Instanzen ab, bei denen `C_checkpoint_i.cut_height` kleiner ist als der vorherige Cut oder `snapshot_root`/`snapshot_leaf` nicht auf der `C_checkpoint_history_{i-1}`-Kette aufbauen. Damit kann kein Block frühere Pruning-Snapshots rückwirkend entfernen oder einen alten Snapshot als „aktuellen“ deklarieren.
- **Append-only Historie:** `C_rpp_history_i` und `C_checkpoint_history_i` müssen entweder identisch mit den Vorgängern sein oder um neue Einträge erweitert werden; Rewrites oder gekürzte Historien führen zu einem Validierungsfehler. Der Folding-Schritt prüft dadurch, dass Pruning-Proofs nur fortgeschrieben, nicht ersetzt werden.
- **State-/Pruning-Konsistenz:** Der Pruning-Commitment-Pfad (`C_rpp_i`) muss auf denselben `C_state_i`-Root verweisen, der im Block-Header steht; ein Mismatch führt zu einer sofortigen Ablehnung und verhindert, dass ein „passender“ Pruning-Beweis eine fremde State-Root signiert. 
- **Cutover-Parameter validieren:** Falls `ProofVersion::NovaV2` aktiv ist, müssen die eingebetteten Cut-/Checkpoint-Metadaten zu dem Cutover-Block passen (z. B. erwartete `cut_height`/`cut_epoch`). Blöcke, die die Cutover-Checkpoints überspringen, werden mit denselben `FOLD-STEP-*` Codes wie andere Instanzfehler abgelehnt.【F:rpp/zk/backend-interface/src/proof_version.rs†L11-L34】

## 5. Nutzung von Checkpoints für Proof-Download und History-Restore
- **Checkpoint-gestützte Proof-Suche:** Validatoren und Light Clients können das `global_proof_handle` in Kombination mit `C_checkpoint_i` nutzen, um gezielt denjenigen Nova-Beweis abzurufen, der auf einem bekannten Snapshot-Cut aufsetzt. Peers veröffentlichen Proof-Blobs unter dem Commitment-Key; Clients filtern Kandidaten, deren eingebettete `cut_height`/`snapshot_root` nicht zu ihren lokalen Checkpoint-Metadaten passen, und vermeiden so vollständige Downloads falscher Beweise.【F:rpp/zk/backend-interface/src/folding.rs†L87-L143】
- **History-Restore beschleunigen:** Beim Wiederaufbau einer Node-Historie kann der Ledger-Store zunächst den neuesten bekannten Checkpoint (`cut_height`, `snapshot_root`) laden, die dazugehörigen GlobalInstances aus den Block-Headern rekonstruieren und nur die fehlenden Beweise seit dem Cut herunterladen. Die Pruning-Roots in `C_rpp_history_i` stellen sicher, dass nur die benötigten State-/Pruning-Abschnitte geladen werden, während ältere Abschnitte prunable bleiben.
- **Prunability trotz Checkpoints:** Alle Checkpoint-Felder (`C_checkpoint_i`, `C_checkpoint_history_i`) werden als kommittierte, aber nicht persistente Payload gehalten und können nach erfolgreicher Verifikation verworfen werden. Full Nodes behalten lediglich die Header- und Proof-Handles (content-addressed), sodass Checkpoints den Storage-Footprint nicht erhöhen und alte Beweise weiterhin geschnitten werden können, sobald ihre Commitments in neueren Instanzen referenziert sind.【F:rpp/zk/backend-interface/src/folding.rs†L13-L85】

## 6. `global_proof_handle` im Header referenzieren
- **Handle anstelle des Voll-Beweises:** Der Folding-Schritt erzeugt einen `global_proof_handle`, der nur aus einem Proof-Commitment (Blake2s über die Proof-Bytes), einer eindeutig benannten Verifikationsschlüssel-ID und einer versionierten Kennung (`ProofVersion`) besteht. Der Voll-Beweis verbleibt im Prover/Storage, während der Header nur den Handle aufnimmt und damit keine wachsenden Arrays oder variablen Byte-Längen transportieren muss.【F:rpp/zk/backend-interface/src/folding.rs†L13-L85】【F:rpp/zk/backend-interface/src/folding.rs†L87-L143】
- **Referenzierung im Block-Header:** Das Commitment aus dem Handle kann als neues Feld (`global_proof_handle`) oder als Subfeld von `proof_root` in den Header gespiegelt werden. Validatoren müssen lediglich das Commitment, die VK-ID und die `ProofVersion` aus dem Header extrahieren und können damit den passenden Verifikationsschlüssel nachladen und den Voll-Beweis aus Storage beziehen, ohne dass der Block selbst den Beweis-Blob trägt.
- **Content-Addressable Proof-Storage:** Das `proof_commitment` dient gleichzeitig als Lookup-Key für den Proof-Blob (`cas://global-proof/<proof_commitment>`). Full Nodes veröffentlichen Proofs über RPC oder Gossip-Blobs unter diesem Key; Light Clients können denselben Key gegen mehrere Peers versuchen, Streaming-Hashing nutzen und Downloads abbrechen, sobald der Hash vom Commitment abweicht.
- **Versionierte VK-Auswahl:** Die `ProofVersion` unterscheidet z. B. `AggregatedV1` (aktueller aggregierter Pfad) von `NovaV2` (alternativer Backend-Pfad) und verhindert, dass ein Header einen Beweis mit einem unerwarteten Layout/Verifikationsschlüssel-Format referenziert. Damit bleibt die API kompatibel, falls der Folding-Prover auf einen neuen Backend-Pfad migriert.【F:rpp/zk/backend-interface/src/proof_version.rs†L8-L34】

## 7. `ProofVersion`-Cutover und Fallbacks
- **Zentrale Enum in gemeinsamer Crate:** `ProofVersion` liegt in `prover-backend-interface` und ist damit sowohl für Prover- als auch Validator-Komponenten verfügbar. `AggregatedV1` kennzeichnet den bisherigen Aggregationspfad, `NovaV2` aktiviert den Nova-Folding-Stack.【F:rpp/zk/backend-interface/src/proof_version.rs†L8-L18】
- **Erzwungener Umschaltpunkt:** Ab Blockhöhe `1_500_000` bzw. Epoche `300` akzeptieren Validatoren nur noch `NovaV2`-Handles; ältere Blöcke bleiben mit `AggregatedV1` kompatibel, falls das Cutover nicht erreicht ist.【F:rpp/zk/backend-interface/src/proof_version.rs†L11-L34】
- **Deterministische Auswahl:** `ProofVersion::for_height_and_epoch` erlaubt beiden Rollen, die korrekte Version anhand der bekannten Blockhöhe/Epoche abzuleiten und fällt für Altketten deterministisch auf `AggregatedV1` zurück, falls kein Cutover-Kriterium erfüllt ist.【F:rpp/zk/backend-interface/src/proof_version.rs†L20-L34】

## 8. Bootstrap von `I_\text{boot}` und `π_\text{boot}`
- **Genesis- oder Cut-Basis:** Der initiale Folding-Zustand (`I_\text{boot}`) wird entweder direkt aus dem Genesis-Header aufgebaut oder aus einem signierten Cut/Snapshot übernommen, falls die Chain bereits Fortschritt hat. Der dazugehörige Startbeweis (`π_\text{boot}`) wird in Storage hinterlegt, sodass der erste Folding-Schritt deterministisch an die bestehende Kette anschließen kann.
- **Umschaltpunkt persistieren:** Beim Übergang auf `NovaV2` wird der Blockhöhe/Epoche-Cutover (`1_500_000`/`300`) zusammen mit `I_\text{boot}` und `π_\text{boot}` persistiert. Dadurch wissen Prover und Validator, ab wann neue Proof-Handles zwingend Nova-konform sein müssen, während ältere Höhen weiter `AggregatedV1` nutzen dürfen.【F:rpp/zk/backend-interface/src/proof_version.rs†L11-L34】

## 9. Fehlermodi, Detektion und Telemetrie
- **`block_witness` fehlerhaft:** Out-of-order Blöcke (`FOLD-STEP-001`), leere Payloads (`FOLD-STEP-002`) oder übergroße Witnesses (`FOLD-STEP-003`) werden direkt in `fold_pipeline_step` verworfen und mit einem `warn!` unter dem Target `folding.pipeline` geloggt.【F:rpp/zk/backend-interface/src/folding.rs†L418-L465】【F:rpp/zk/backend-interface/src/folding.rs†L506-L548】
- **Manipuliertes `I_prev`/Proof-Paar:** Fehlende Instanz-Commitments (`FOLD-STEP-010`) oder ein Mismatch zwischen `I_prev` und `proof_prev` (`FOLD-STEP-011`) lösen ebenfalls einen instrumentierten Reject aus; dadurch landen sowohl Prover-Logs als auch Telemetrie-Metriken auf denselben Codes.【F:rpp/zk/backend-interface/src/folding.rs†L431-L454】
- **Inkonsistente `vk_id` oder Handles:** Validatoren versehen jede Header-/Payload-Abweichung mit standardisierten Codes (`FOLD-V-003` bis `FOLD-V-009`) und schreiben sie auf `folding.validator`, z. B. bei fehlerhafter `vk_id` (`FOLD-V-005`) oder versionierten Labels (`FOLD-V-006`/`FOLD-V-008`).【F:rpp/runtime/types/block.rs†L30-L119】【F:rpp/runtime/types/block.rs†L459-L527】

## 10. Reject-Codes für Konsens und Light Clients
- **Prover/Consensus:** `fold_pipeline_step` prefixed alle frühen Validierungsfehler mit `FOLD-STEP-*` und bettet die Codes in die Fehlermeldung ein, sodass Konsensknoten und Monitoring-Systeme denselben Fehlertext sehen wie die Telemetrie-Events. Backend-Ablehnungen werden unter `FOLD-STEP-099` zusammengefasst.【F:rpp/zk/backend-interface/src/folding.rs†L404-L548】
- **Validator/Light Clients:** Bei der Verifikation von `global_proof_handle` und Payload werden deterministische `FOLD-V-*` Codes verwendet. Fehlende Proof-Blobs werden z. B. als `FOLD-V-010` (`InvalidProof`) ausgegeben, während kryptografische Abweichungen als `Crypto`-Fehler mit den Codes `FOLD-V-001`–`FOLD-V-009` zurückgegeben werden.【F:rpp/runtime/types/block.rs†L459-L544】
